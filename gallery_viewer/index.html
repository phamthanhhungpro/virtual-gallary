<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>The Gallary</title>
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
	<!-- Bootstrap Icons CSS (optional) -->
	<link href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css" rel="stylesheet">
	<!-- add app.css here -->
	<link href="app.css" rel="stylesheet">
	<script src="https://cdn.babylonjs.com/babylon.js"></script>
	<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
	<script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>

	<script src="https://unpkg.com/earcut@2.1.1/dist/earcut.min.js"></script>
	<link rel="icon" type="image/x-icon" href="../favicon.ico">

</head>

<body>

	<div id="overlay">
		<div id="imageContainer">
			<img id="image1" alt="Instruction 1" class="instruction-image">
			<img id="image2" alt="Instruction 2" class="instruction-image">
		</div>
	</div>


	<div class="container">
		<span class="loader" id="loader"></span>
	</div>

	<!-- <div id="loader">
		<p>Loading gallery</p>
		<div id="loadingContainer">
			<div id="loadingBar"></div>
		</div>
		<p id="percentLoaded">0%</p>
	</div> -->

	<div class="container detail-mode" id="detailsBox" style="display: none;">
		<span class="icon close-icon float-end" onclick="hideDetailBox()">
			<i class="bi bi-x-lg"></i>
		</span>

		<div id="detailsContent" class="p-3">
			<h6 id="artTitle"></h6>
		</div>
		<!-- add next and previos button -->
		<div id="detailsButtons">
			<span class="icon previous-icon" onclick="preArt()">
				<i class="bi bi-arrow-left"></i>
			</span>
			<span class="icon next-icon" onclick="nextArt()">
				<i class="bi bi-arrow-right"></i>
			</span>
		</div>
	</div>

	<canvas id="renderCanvas" touch-action="none"></canvas>

	<script>
		// user custom variables that you need to modify
		const asset_location = '/';
		const config_file_name = '/building.json';
		const styles_file_name = '/styles.json'
		const materials_folder = '/materials';
		const hallspics_prefix = '';

		const aux_javascript = 'room_builder_aux.js';
		// -------------------------------------------------------


		var script = document.createElement('script');
		script.src = aux_javascript;
		document.body.appendChild(script);

		//user custom variables that are not modified in general
		const add_light = true;
		const debug_scene = true;
		const with_ceiling = true;
		const margin = 0.2; 			//frame margin
		const item_separation = 0.1; 	//separation from the wall
		const door_height = 3; // dimensions of the door to the parent gallery
		const door_width = 2;


		//program constants
		const regul_exp_door = /^d_/;
		const regul_exp_tail = /_[0-9]*$/;
		const regul_exp_artworks = /.*pic$/;

		//declarations
		var canvas = document.getElementById("renderCanvas");

		var sceneToRender = null;
		let config_file_content;
		let style_file_content;
		let fontContent;
		var galleries = new Object();
		var scene = null;
		var current_gallery;
		var door_material, wall_material, floor_material, header_material;

		//device detections
		var isTouchDevice = false;

		// index of selection art
		var index = 0;

		if (('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0)) {
			isTouchDevice = true;
			document.getElementById('image1').src = "/icons/touch_move.png";
			document.getElementById('image2').src = "/icons/touch_pan.png";
		} else {
			document.getElementById('image1').src = "/icons/keyboard_move.png";
			document.getElementById('image2').src = "/icons/keyboard_pan.png";
		}



		var deviceAgent = navigator.userAgent.toLowerCase();
		isTouchDevice = (deviceAgent.match(/(iphone|ipod|ipad)/) || deviceAgent.match(/(android)/) || deviceAgent.match(/(iemobile)/) || deviceAgent.match(/iphone/i) || deviceAgent.match(/ipad/i) || deviceAgent.match(/ipod/i) || deviceAgent.match(/blackberry/i) || deviceAgent.match(/bada/i));

		//loads the gallery file and updates the loading bar
		var loadAsset = async (file, scene) => {
			return new Promise((res, rej) => {

				if (document.getElementById("loaded") != undefined) {
					document.getElementById("loaded").id = "loader";
					document.getElementById("loader").style.display = "flex";
					document.getElementById("loadingBar").style.width = "0%";
				};
				BABYLON.SceneLoader.LoadAssetContainer(asset_location, file, scene, function (container) {
					document.getElementById("loader").style.display = "none";
					document.getElementById("loader").id = "loaded";
					setTimeout(() => { document.getElementById("loaded").style.display = "none"; }, 7000);
					if (container.cameras) {
						container.cameras.pop();
					}
					res(container)
				},
					function (evt) {
						// onProgress
						var loadedPercent = 0;
						if (evt.lengthComputable) {
							let total = evt.total;
							if (evt.srcElement.getResponseHeader('content-encoding')) {
								//compressed content assume 25% compression
								total = total * 0.75;
							}
							loadedPercent = (evt.loaded * 100 / total).toFixed();
						} else {
							//assume a 50MB file
							loadedPercent = (evt.loaded * 100 / 50000000).toFixed();
						};

						document.getElementById("percentLoaded").innerHTML = `${loadedPercent}%`;
						document.getElementById("loadingBar").style.width = `${loadedPercent}%`;

					});
			})
		}


		// ******************************************new
		function showInfoBox(title) {
			document.getElementById("artTitle").innerText = title;
			document.getElementById("infoBox").style.display = "block";
		}

		function reposition_lights(room_name) {
			let L = config_file_content[room_name]["geometry"][1];
			let H = config_file_content[room_name]["geometry"][2];
			scene.getLightByName("pointlight").position = new BABYLON.Vector3(0, H - 0.5, 0);
			scene.getLightByName("pointlight2").position = new BABYLON.Vector3(0, H - 0.5, (L / 2) * 0.75);
			scene.getLightByName("pointlight3").position = new BABYLON.Vector3(0, H - 0.5, -(L / 2) * 0.75);
		}

		function auto_uv_scale(room_name) {
			let W = config_file_content[room_name]["geometry"][0];
			let L = config_file_content[room_name]["geometry"][1];
			let H = config_file_content[room_name]["geometry"][2];

			//scale floor
			var material = scene.getMeshByName("floor").material;
			var floor_style = style_file_content.chosenStyles.chosenFloorStyle;
			var floor_style_data = style_file_content.styles.floorStyles.find(style => style.styleName === floor_style);

			// Get all the available textures from the material
			var textures = material.getActiveTextures();

			// Loop through the textures array
			for (var i = 0; i < textures.length; i++) {
				textures[i].uScale = floor_style_data.uvScaling.uScale;
				textures[i].vScale = floor_style_data.uvScaling.vScale;
			}

			//scale walls
			var material = scene.getMeshByName("wall_n").material;
			var wall_style = style_file_content.chosenStyles.chosenWallStyle;
			var wall_style_data = style_file_content.styles.wallStyles.find(style => style.styleName === wall_style);

			// Get all the available textures from the material
			var textures = material.getActiveTextures();

			// Loop through the textures array
			for (var i = 0; i < textures.length; i++) {
				textures[i].uScale = wall_style_data.uvScaling.uScale;
				textures[i].vScale = wall_style_data.uvScaling.vScale;
			}
		}

		function doesFileExist(urlToFile) {
			var xhr = new XMLHttpRequest();
			xhr.open('HEAD', urlToFile, false);
			xhr.send();

			if (xhr.status == "404") {
				return false;
			} else {
				return true;
			}
		}

		window.initFunction = async function () {
			var createDefaultEngine = function () {
				return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, disableWebGL2Support: false });
			};

			var asyncEngineCreation = async function () {
				try {
					return createDefaultEngine();
				} catch (e) {
					console.log("the available createEngine function failed. Creating the default engine instead");
					return createDefaultEngine();
				}
			}




			var startRenderLoop = function (engine, canvas) {
				engine.runRenderLoop(function () {
					if (sceneToRender && sceneToRender.activeCamera) {
						sceneToRender.render();
					}
				});
			}
			var createScene = function () {
				var scene = new BABYLON.Scene(engine);

				//add default camera
				const camera = new BABYLON.UniversalCamera("camera", new BABYLON.Vector3(0, 3, 0), scene);
				camera.attachControl();

				camera.applyGravity = true;
				camera.checkCollisions = true;

				camera.ellipsoid = new BABYLON.Vector3(1, 1.2, 1);

				if (isTouchDevice) {
					camera.minZ = 0.045;
					camera.speed = 0.25;
					//camera.angularSensibility = 4000;

					camera.touchAngularSensibility = 15000; //higher is slower
					camera.touchMoveSensibility = 600;


				} else {
					camera.minZ = 0.45;
					camera.speed = 0.25;
					camera.angularSensibility = 4000;

					camera.keysUp.push(87);
					camera.keysLeft.push(65);
					camera.keysDown.push(83);
					camera.keysRight.push(68);
				}




				if (add_light) {
					var light0 = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0, 1, 0), scene);
					var light00 = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0, -1, 0), scene);


					var light = new BABYLON.PointLight("pointlight", new BABYLON.Vector3(0, 3, 0), scene);
					var light2 = new BABYLON.PointLight("pointlight2", new BABYLON.Vector3(0, 3, 4), scene);
					var light3 = new BABYLON.PointLight("pointlight3", new BABYLON.Vector3(0, 3, -4), scene);
					light0.intensity = config_file_content["Technical"]["ambientLight"];
					light00.intensity = config_file_content["Technical"]["ambientLight"] / 2;
					light.intensity = config_file_content["Technical"]["pointLight"];
					light2.intensity = config_file_content["Technical"]["pointLight"];
					light3.intensity = config_file_content["Technical"]["pointLight"];
				}

				scene.clearColor = new BABYLON.Color3(0.2, 0.3, 0.4);

				return scene;
			}

			//receives the events to switch galleries
			let galleryManager = async function (evt) {
				console.log(evt);

				//only in the first run
				if ('first' in evt) {
					console.log('Root gallery booting');
				} else {
					//move elements away from scene unless previously cached

					var keepAssets = new BABYLON.KeepAssets();
					keepAssets.cameras.push(scene.cameras[0]);
					keepAssets.lights.push(scene.lights[0]);
					keepAssets.lights.push(scene.lights[1]);
					keepAssets.lights.push(scene.lights[2]);
					keepAssets.lights.push(scene.lights[3]);
					keepAssets.lights.push(scene.lights[4]);

					if (galleries[current_gallery] == undefined) {
						galleries[current_gallery] = new BABYLON.AssetContainer(scene);
						galleries[current_gallery].moveAllFromScene(keepAssets);
					} else {
						//if cached simply drop them
						//let temp_assetcontainer=new BABYLON.AssetContainer(scene);
						//temp_assetcontainer.moveAllFromScene(keepAssets);
						galleries[current_gallery].removeFromScene();
					}
				}


				//the current gallery is updated with the user choice
				current_gallery = evt.source.name ?? evt.source.id;
				current_gallery = current_gallery.replace(regul_exp_tail, "");


				current_gallery_file = current_gallery.replace(regul_exp_tail, "");
				current_gallery_file = current_gallery_file.replace(regul_exp_door, "");

				//the new gallery assets are loaded unless they are already in memory
				if (galleries[current_gallery] == undefined) {
					await rb(config_file_content, current_gallery_file, scene);
					//remove the loading bar if visible
					if (document.getElementById("loader") != undefined) {
						document.getElementById("loader").style.display = "none";
						document.getElementById("loader").id = "loaded";
					}
					//reposition lights
					reposition_lights(current_gallery_file);

				} else {
					galleries[current_gallery]._wasAddedToScene = false;
					galleries[current_gallery].addAllToScene();
				}



				//reset camera position
				scene.cameras[0].position = new BABYLON.Vector3(0, 2.4, 0);

				//************************************************************new
				//locate doors and artwork to setup the action manager
				gallery_doors = [];
				gallery_artworks = [];
				scene.meshes.map((mesh) => {
					mesh.checkCollisions = true;
					if (regul_exp_door.test(mesh.name)) {
						gallery_doors.push(mesh.name);
					} else if (regul_exp_artworks.test(mesh.name)) {
						gallery_artworks.push(mesh.name);
					}
				});

				for (const door of gallery_doors){
					scene.getMeshByName(door).actionManager = new BABYLON.ActionManager();
					scene.getMeshByName(door).actionManager.registerAction(new BABYLON.ExecuteCodeAction(
									BABYLON.ActionManager.OnPickTrigger, galleryManager	));
				}

				// add event listener for click door
				// canvas.addEventListener("click", function (evt) {
				// 	var pickResult = scene.pick(scene.pointerX, scene.pointerY);
				// 	if (pickResult.hit) {
				// 		var mesh = pickResult.pickedMesh;
				// 		console.log("Door clicked", mesh.name);

				// 		if (mesh.name.includes("mesh")) {

				// 			galleryManager(evt);
				// 		}
				// 	}
				// });

				for (const artwork of gallery_artworks) {

					var mesh = scene.getMeshByName(artwork);
					mesh.actionManager = new BABYLON.ActionManager();
					// camera focus on the mesh by clicking
					mesh.actionManager.registerAction(
						new BABYLON.ExecuteCodeAction(
							{ trigger: BABYLON.ActionManager.OnPickTrigger },
							function (event) {
								// get the index of the artwork
								index = gallery_artworks.indexOf(artwork);

								zoom(scene.cameras[0], scene.getMeshByName(artwork));

								// show a box with the content of the artwork
								showDetailBox(artwork);
							}
						));

				}
				if ('first' in evt) {
					document.getElementById("overlay").style.display = "flex";
					setTimeout(function () {
						document.getElementById("overlay").style.display = "none";
					}, 3000);
				}
			}

			// MAIN CODE /////////////////////////////////////
			//read font	
			let fontfile = await fetch("https://assets.babylonjs.com/fonts/Droid Sans_Regular.json");
			fontContent = await fontfile.json();

			//read json files
			let response = await fetch(config_file_name);
			config_file_content = await response.json();



			//galleries=Object.keys(config_file_content);

			window.engine = await asyncEngineCreation();
			if (!engine) throw 'engine should not be null.';
			startRenderLoop(engine, canvas);

			//crete the scene
			window.current_gallery = "root"
			scene = createScene();
			const framesPerSecond = 60;
			const gravity = -9.81;
			scene.gravity = new BABYLON.Vector3(0, gravity / framesPerSecond, 0);
			scene.collisionsEnabled = true;

			//materials
			await read_styles(styles_file_name);




			//trigger a dummy event to render the root gallery
			let evt = { source: { id: "d_root_1" } };
			//evt.source.id="d_root"
			evt.first = 1;
			await galleryManager(evt);

		}

		initFunction().then(() => { sceneToRender = scene });


		var zoom = function (cam, tar) {
			console.log("zooming");
			var targetEndPos = tar.getAbsolutePosition();
			var camEndPos = tar.getAbsolutePosition();
			var speed = 45;
			var ease = new BABYLON.CubicEase();

			tar.computeWorldMatrix();
			var matrix = tar.getWorldMatrix(true);
			var local_position = new BABYLON.Vector3(0, 0, 0);
			local_position.addInPlace(new BABYLON.Vector3(0, 0, -5));
			var global_position = BABYLON.Vector3.TransformCoordinates(local_position, matrix);

			ease.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);
			BABYLON.Animation.CreateAndStartAnimation('at4', cam, 'position', speed, 120, cam.position, global_position, 0, ease);
			BABYLON.Animation.CreateAndStartAnimation('at5', cam, 'target', speed, 120, cam.target, targetEndPos, 0, ease);
		};

		function showDetailBox(title) {
			title = title.split("_")[0];
			document.getElementById("artTitle").innerText = title;
			document.getElementById("detailsBox").style.display = "block";
		}

		function hideDetailBox() {
			document.getElementById("detailsBox").style.display = "none";
		}

		function preArt() {
			if (index == 0) {
				index = gallery_artworks.length;
			}
			index -= 1;
			zoom(scene.cameras[0], scene.getMeshByName(gallery_artworks[index]));
		}

		function nextArt() {
			if (index == gallery_artworks.length - 1) {
				index = -1;
			}
			index += 1;
			zoom(scene.cameras[0], scene.getMeshByName(gallery_artworks[index]));
		}

		// listen event click a mesh
		// canvas.addEventListener("click", function (evt) {
		// 	var pickResult = scene.pick(scene.pointerX, scene.pointerY);
		// 	if (pickResult.hit) {
		// 		var mesh = pickResult.pickedMesh;
		// 		if (mesh.name.includes("mesh")) {
		// 			mesh.actionManager = new BABYLON.ActionManager();
		// 			mesh.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
		// 				BABYLON.ActionManager.OnPickTrigger, galleryManager));
		// 		}

		// 	}
		// });


	</script>
</body>

</html>